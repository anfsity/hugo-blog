[{"content":"目前施工正在进行中，目前仅作完 DataLab\n实验目录 DataLab - Jun 27, 2025 Three Day Sprint - Jun 25, 2025 迁移总结 - Jun 24, 2025 浅谈筛法 - May 25, 2025 Multiplicative Inverse - May 25, 2025 C\u0026#43;\u0026#43; 杂项 - May 24, 2025 No Title - May 24, 2025 GCD and LCM - Apr 21, 2025 Linear Algebra - Oct 17, 2024 Markdown Syntax Guide - Mar 11, 2019 Rich Content - Mar 10, 2019 Placeholder Text - Mar 9, 2019 Math Typesetting - Mar 8, 2019 Emoji Support - Mar 5, 2019 实用链接 CSAPP Lab 备份 CSAPP 电子汉化版 不周山的博客 CSAPP 重点解读 感想 ","date":"2025-06-27T19:29:03+08:00","image":"https://i.111666.best/image/WlxWjkwsJem51r4djTr0Bl.jpeg","permalink":"http://localhost:1313/p/csapp/","title":"CS:APP"},{"content":" 以下所有内容引用自 上海交大生存手册\n突击备考 新书或者根本没买过书；没听过讲，或者没上过课，没独立写做过作业甚至没交过作业，但是离考试只有三天时间，这样的情况，对我们中的大部分人，对大部分课程的考试，并不意味着绝望。只要你有心，三天造十万支箭都没有问题，更何况考试？\n我并不是一个“优秀”的学生，因为在大学四年内，我没有一个光鲜的GPA。虽然我可以很骄傲地说，这四年，我把本该上课的时间用来做了更重要更有意义的事情。但是面对考试能拿到一个过得去的分数也是我的底线。我相信，并不是每个交大的学生都会很乐意的接受挂科、甚至退学这样的经历。\n并不是所有同学都能够像我一样幸运地找到一些比上课正确一百倍的事情去做。而我们在这一节里分享的，更多是拿到70分而不是90分的经验。如果你在阅读本书《立志篇》之后，你的目标仍然是得到全A。或者说，你找不到比上课更有意义的事情，那么你们应该去自习室，而不是在这里听我扯淡。\n突击备考的一个必要前提是，我们把时间用来做了更重要的事情。\n从学习知识而言，上课是一件奢侈的事情。对突击复习考试而言，所谓的“慢工出细活”也是奢侈的。如果你认为这门课不重要，请不要在两个星期以前开始复习，因为两个星期足够让你忘掉其中一大半的知识。通常，有效的复习是在3天之内开始的，因人略有差异。我不否认个人之间的IQ存在差异，但是这种差异是如此之小，以至于甚至不能成为左右考试成绩的主导因素。充其量，有些同学可以以笨鸟先飞的名义，把一门课程需要的复习时间从3天延长到5天，不会更多。当然，我们这里说的是针对大多数靠突击有可能能拿高分的课程。某些课程（诸如高等数学），显然是排除在我们的讨论范围之外的。一般一门课如果在历史上曾经挂了学院1/3以上的同学，那么对于该课程就需要提高警惕，慎重起见，甚至不要突击复习。\n注意复习范围 通常老师在复习课上都会把考点和考试范围告诉大家。对考点的正确解读可以让你事半功倍。比如，有一些脸皮比较薄的老师在划考点的时候，不喜欢明目张胆地说“这章不考”，而是会换一种更加委婉的说法，比如“这章的内容主要是介绍性的，有兴趣的同学们可以进一步拓展”。我相信大部分同学对于这样的话都能有正确的理解。至于考点的准确性，我认为我们不应该心中有任何疑问。虽然的确存在过老师说不考的地方真的考了，但是那种事情出现几率非常低，每学年近二十科考试，能出一次就不错。而且真的没复习到所带来的影响也不是决定性的。所以我们在考前最后一节课上，一定要毫无保留地相信老师、相信考点，并且，还要相信不同老师考点的交集。\n三天冲刺 3天之内，你需要准备的：\n课本（没错，就是这门课的教材）\n上课 PPT ，如果你的老师的PPT只是把教材原样照搬的话\n一位懂得这门课程的朋友\n平时作业列表\n全书考点（或者不考的点）的列表\n首先，请懂得这门课程的朋友吃饭，让他用半小时的时间，用通俗语言，按章节给你介绍这门课是做什么的，每一部分的考点是什么。吃饭结束之后，和他约考试前一天下一次见面的时间。然后翻开教材，看目录，将不需要考的内容划掉。回忆那位朋友的话，想象每一章的标题所代表的内容。以3倍速的速度将书翻一遍，无论看懂不看懂，进一步领会朋友所说的话，如果是理工类课程，争取每章自己总结一个能够说服自己的理论。\n找出平时作业列表，当然了，通常来说你肯定是一道题目也不会做。这很正常，你不必为此感到紧张或绝望，不上课直接做作业本这本身就是让人绝望的。你需要做的是，把作业和答案放在一起，开始扫荡，用半天的时间保证你知道答案的那些数是怎么算出来的。注意：你没有时间一道一道题目去做，把你高中老师告诉你的要扎扎实实的说法抛到脑后吧，扎扎实实你应该好好上课去。\n如果顺利搞明白了作业，你现在大约可以考40分了。你会遇到一些情况，比如作业题目你看不懂，你不知道答案上面那些鬼东西是在说什么。勾上相关的章节。将刚刚勾过的章节逐一以两倍速浏览，注意看公式和黑体字。你会发现你小学套公式，中学套公式，到了大学，还是在套公式。接下来你只需要把你不会的题代到相关章节的相关公式下，做好字母和中文的对应翻译工作。\n现在你不会的题目应该很少了。这会儿开始看 PPT。注意，不要一开始就看 PPT，当然，更不要一边看 PPT 一边看 B站 。知识是书上来的，PPT 是演讲稿，不要因为懒不去翻书。\n有些关键点，看课本看不懂，就去看 PPT （因为教课书在关键点上总喜欢使用脑残体），看 PPT 看不懂（部分 PPT 写的和书一样脑残，而且还有错），就去看课本；再不行还有 Google 和 GPT。如果在非常关键的知识点遇到了无论如何都不明白的情况，那就赶紧抄起电话，找到你的那个朋友求助。\n在考试之前前一天之内，把所有的公式或者解题步骤都写在一张纸上，用剩下除睡觉之外的时间去熟悉这张纸，根据例题的形式在脑中按照这个套路演练。但是不要试图拿着这张纸作弊——风险太大回报太低不合算；把上面的内容抄到桌子上也不可取——在考试时，你根本不会有机会去把桌面当图书馆查来查去，这样做只会让你心虚，一边惦记这个事儿一边浪费大量时间。考试的时候，尽量不要抄周围同学的，因为你周围的人复习的不一定比你好。\n如果你前面工作做的足够好，那你一定要有信心。题目要么你都会做，要么大家都不会做。关于选择题，请尽量用你的大脑，不要胡猜。要记住这是你和出题人 IQ 的比拼，而不是 rp 的比拼。\n考试结束后 一哭二闹三上吊是下下策，只有当其他的手段都无效时，再考虑这样的办法。对于某些老师，你唯一的选择就是考到80+。对于另外一些比较好说话的老师，你可以跟他们谈谈你对课程的理解，以及对这门学科的看法。在谈话中，最佳的切入点是学术。你要尽可能地讨论学术方面的问题，而不是去强调你要出国，你要保研。每个人都有各种各样的私人借口来要求一个好的成绩，但是这些借口并不一定都能成为让老师帮你一把的理由。\n请注意，如果你希望老师帮你一把，尤其是你大概率要挂科的时候，请一定线下前往老师的办公室或电话沟通，不要用邮件或微信让老师难办。如果老师在提交成绩前放出了成绩预览，那么这就是你努力的时机了。但即使你的成绩单上已经是Fail，也并不是没有办法的，虽然修改已经提交的成绩超过一定比例会认定为教学事故，不过要是你面临着退警，请不要放弃任何机会。但请注意不要违反法律，不要出卖自己的尊严。\n复习箴言 1.请保证这三天时间80%以上的利用率，睡觉也要尽量克制些。\n2.不要打游戏，也不要刷B站，如果考试跟电脑无关，尽量少开电脑。\n3.多参加专业群内的讨论，狠狠鄙视那些不愿意跟大伙分享心得的家伙。\n4.你可以总结出对这门课程的几个独创理论，比如你对某一章节的独特理解，分享这些经验，这会帮助很多人。\n5.如果你有考点搞不太清楚，不要浪费过多的时间试图让自己“真的搞懂”。只要你能把解题步骤记牢，保证大部分习题都算对就是胜利。\n6.有一些课程没有习题，或者说老师布置的作业没有代表性，那你必须需要去购买一本习题集，或者看别人的上课笔记\n7.做题一定要找有答案的，你没有时间去自己确定你做的每一个答案是否正确。\n8.如果可能，把那些不是作业题的里面的一些有趣的内容也看一下。\n9.不要不去考试，无论如何，应该尝试一下。而且很有可能补考卷子和考试卷子重合度较高。\n10.考试结束后，无论感觉好坏，别忘了请辅导你的那个朋友吃饭。\n$end$\n个人感想 作为一个从小到大从来没有过考前突击经验的人，我当初刚看见这篇文章是十分震惊的。震惊的是，我从来没想过考试可以这么做。但震惊之余，我马上觉悟这个方法的可行性。\n当然，那个时候的我仅仅是对这篇文章留有比较深刻的印象，并有没亲自去做出实践。原因是我并没有找到我认为是更有意义的事，不过现在不太一样。\n在我亲自体验过这个方法之后，我决定写下一些感想以及总结。\n首先，面对考试拿一个还算过得去的分数也是我的底线，我并不乐意接受挂科，甚至退学的经历。\n突击备考只能针对突击备考有可能考到高分的课程。对于某些课程，比如数学分析，是不应该这么做的。对于一门课挂科率超过 30% 的话，对这门课就要 提高警惕。但是，这是针对上海交大而言，对于我这种破大专就不一样了。我个人估计，我这门专业在学校里面，几乎所有的课程都可以在 6days 以内速成。 绝大多数的课程有三天是完全充足的，并且如果你完全按照计划执行的话，大概率分数不会低。至于那几个特例嘛，是因为那两门课的挂科率在 50% 左右。 不过这也是我觉得这个专业为数不多有价值的课程了。\n讲讲不在这三天之内要做的事情。首先，你需要收集这门课程的历年试卷，一门课程的考试内容往往持续十几年都不会改变。如果可能的话，提前准备 全书考点，每次上课后向听课的同学请教这节课的知识点。这花不了多少时间，但是对后期的准备是十分方便的。打听打听这门课程老师的脾性。如果 可能的话，尽可能把平时分刷高，虽然不太可能。\n然后就是突击备考中间的事情了：\n你这门课的课本可能极其的差(如果你听不懂这门课，绝对不是你太蠢，而是这本教材/老师太垃圾)。这个时候你就需要去网上找资料，这个过程可能是十分费劲的，为了应对这种情况，我建议你可以提前准备。\n你可能找不到一门懂得这么课程的朋友。或者说有这么一个人，但是很难沟通。也有可能，他是你的朋友，他也明白，但是不知道怎么讲给别人听。 这个时候就只能求己了，所幸现在有各种 LLM 辅助，让这个环节不至于如此的致命。或者也可以去网上的相关交流群去提问，提问的时候请遵循提问的 智慧。\n有些老师是不会给你具体的复习范围的，这个时候就需要你自己动手了。网上关于这门课的考点不一定是你的考点，你只能从作业和往年试卷中追求蛛丝马迹。\n作业和习题是十分重要的。但是有些时候，老师布置的作业只会给你判断对错，并不给你答案。这个时候你需要去找一本贴合你的教材的习题参考册， 结合你作业类型的题去刷。最重要的是，习题参考册并不总是这么简单就可以找到的。请提前准备防止这种情况发生。\n睡觉少睡一些，如果考试在上午的话，可以考虑通宵。当然，长达20多个小时的长线作战是十分痛苦的。你不可能完完整整的利用这几十个小时的每一分， 每一秒，你应该尽可能高效的利用这每一分，每一秒。请劳逸结合，但也不能过度放松。\n相信墨菲定律，你看见而不想学的知识点，极有可能你会在考场上遇到。所以，请不要遗漏任何一个知识点。\n如作者所言，不要去看视频听课。你不是学会一个知识点，而是学会做这个知识点的题。给每个章节一个或几个结论，可以很好的帮助你备考。\n文中提到了一些课程内的交流群，如果你的课程交流群一个活人都没有，请放弃这条道路。不过，向老师提问是一个不错的选择。\n相信这本书的内容，我认为里面的内容是极为科学，可行性极强的。如果不知道这种方法，针对突击备考会难上几个系数。\n最后的最后，请记住，突击备考的前提是：\n我们把时间，用来做了更加重要的事。\n","date":"2025-06-25T00:29:21+08:00","permalink":"http://localhost:1313/p/three-day-sprint/","title":"Three Day Sprint"},{"content":"起因是我重装 win10 的时候把我整块磁盘都清空了，事后才发现我没有给我的博客备份😭。遂想，反正已经要 remake 了，索性换一个框架，于是便从 hexo 换成了 hugo。\n虽然说所有的数据我在 vercel 上都有，但是都不是 markdown 的储存形式，我也懒得再从网上找工具实现 html 转 markdown 了。就仅仅迁移了几篇还算有意义的文章。\n其实因为是在 linux 上写的，本地有数据 (。\n新 hugo 主题对比我原来的 hexo 主题有些部件是不完全的，要自己造轮子。比如回到顶部的小按钮，代码块折叠等等。扯句别的，说实话我想吐槽以下那些 live2d 小人，全屏的动态效果和一些鼠标特效等等，难道看的视觉上不会很难受吗()。\n其实也没什么好总结的，无非就是看看文档，找些博客做参考，解决一些疑难杂症。现在有 LLM 辅助，应该是比以前要舒服很多的。但是还是不能依赖于 AI, AI 在某些场景太弱智了。\n不过既然写了一篇博客，就水水字数吧。\n最近把刚上学的时候感兴趣的一个东西实现了，那个时候是在是不懂这些。唉唉，我已经老了啊。\n我记得在 csdiy 上看到一个评论说可以借助 Azure 的 vps 自建节点，便想自己动手试一试，就搞出来了一些明堂。\n首先你要拥有一个 Azure 的学生认证账户，国外学生认证的申请模式都大同小异，也有很多教程，在此就不再赘述。不过如果申请了 github education 的话是会方便很多的，而且 github 的福利也是非常不错的。\n总的来说，思路就是利用 Azure 的虚拟机，通过 OpenVPN，WireGuard 等虚拟加密网络隧道，绕过 GFW,以实现俗称 “翻墙”，“魔法”的效果。\n实现过程倒是很简单，按按鼠标就行。假设你已经拥有了 Azure 的一个学生认证账户(学生认证账户每年可以获得 100$ 的免费额度使用，可重复申请)。那么现在你要做的操作就是打开 Azure 的主页，创建一个虚拟机。\nUbunutu 上就没有好用一点的截图工具吗。。。其他的默认就好不需要修改。\n其他的一路默认就行，注意一下在网络那部分，如果 IP 能该动态就改动态，静态相对而言是很贵的。\n等待虚拟机创建完毕，使用 ssh 进行连接。\n新装的 Ubuntu，输入命令\n1 sudo apt update 爽一爽国外的网速。\n1 sudo apt install wireguard 按照提示即可，然后获得一个 conf\n1 cat *.conf 把输出内容往你本地下载 wireguard app上一丢就行，注意不要同时和另一个软件进行代理，可能会出现不知名的错误。尝试访问 google 和 youtube，如果成功就代表一切都 OK 了。好耶。\nbtw,好快的网!\n1 2 3 4 5 6 7 8 9 10 11 12 13 azureuser@anfsity:~$ ./speedtest Speedtest by Ookla Server: Misaka Network, Inc. - Seattle, WA (id: 50679) ISP: Microsoft Azure Idle Latency: 4.73 ms (jitter: 0.22ms, low: 4.64ms, high: 5.15ms) Download: 5400.52 Mbps (data used: 6.6 GB) 7.65 ms (jitter: 2.84ms, low: 4.57ms, high: 18.57ms) Upload: 922.00 Mbps (data used: 426.3 MB) 8.25 ms (jitter: 1.37ms, low: 4.27ms, high: 12.19ms) Packet Loss: 0.0% Result URL: https://www.speedtest.net/result/c/aae9caa4-acc5-418c-b1b2-419950514d5b 羡慕啊。\n$upd:$\n当初写这个的时候并没有部署到 vercel 上，推上去才发现本地能加载的 svg 图片在上面不行。。。然后我开了一个 fixbug 分支尝试去修复他(我不懂前端哇),进行了一些列改动后，愉悦的出现了神秘 bug ：\n1 2 3 500: INTERNAL_SERVER_ERROR Code: MIDDLEWARE_INVOCATION_FAILED ID: hkg1::5qkdl-1750825759600-8b738d10c1a2 最神秘的是，我在 fixbug 行不通的改动，同步到 main 反而行了，很神秘啊。既然能跑，我就不做改动了。\n","date":"2025-06-24T22:42:13+08:00","image":"https://i.111666.best/image/bFGnilXaGbPyJep2pc2y4L.png","permalink":"http://localhost:1313/p/%E8%BF%81%E7%A7%BB%E6%80%BB%E7%BB%93/","title":"迁移总结"},{"content":"素数筛法 引入 我们先来看一个最基本的一个判断素数的方法， 基于 $6k \\pm 1$ 优化。\n$Prove$\n对于所有正整数，都可以表示为 $6k + i$。\n由于以下情况 :\n$6k \\equiv 0 \\pmod{2}$\n$6k+2 \\equiv 0 \\pmod{2}$\n$6k+3\\equiv 0 \\pmod{3}$\n$6k+4\\equiv 0 \\pmod{2}$\n也就是说， 只有 $6k \\pm 1$ 存在可能为质数的可能， 所以我们只要检查 $6k \\pm 1$ 有没有可能是质数就行了， 这种方法也可以进行推广，但是要筛的数的范围也会随之变大， 不过时间复杂度也会变得更加优秀。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 template \u0026lt;typename type\u0026gt; bool isPrime(type n) { if(n \u0026lt;= 1) return false; if(n \u0026lt;= 3) return true; if(n % 2 == 0 || n % 3 == 0) return false; for(type i = 5; i \u0026lt;= n / i; i += 6) { if(n % i == 0 || n % (i + 2) == 0) return false; } return true; } 这种方法在求较小的质数时相当优秀和简洁， 但是在大范围查询的时候， 就不够适用了，这个时候，就该引入我们的质数筛法了。\n埃拉托斯特尼筛法 朴素版本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 std::vector\u0026lt;int\u0026gt; prime; std::vector\u0026lt;int\u0026gt; vis(N, 0); void Eratosthenes() { for(int i = 2; i \u0026lt;= N; ++i) { if(!vis[i]) { prime.push_back(i); if(1LL * i * i \u0026gt; N) continue; for(int j = i * i; j \u0026lt;= N; j += i) { vis[j] = 1; } } } } 时间复杂度为$O(n\\log \\log(n))$。\n平方根优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 std::vector\u0026lt;int\u0026gt; prime; std::vector\u0026lt;int\u0026gt; vis(N, 0); void Eratosthenes() { for(int i = 2; i * i \u0026lt;= N; ++i) { if(!vis[i]) { for(int j = i * i; j \u0026lt;= N; j += i) { vis[j] = 1; } } } for(int i = 2; i \u0026lt;= N; ++i) { if(!vis[i]) { prime.push_back(i); } } } 该版本对比朴素版本， 仅仅添加了平方根的优化， 时间复杂度为 $O(n\\log \\log(\\sqrt{ n })\\ +\\ n)$, 然而这样会显著优化时间。\n由于我们知道， 合数不可能为素数， 所以我们只需要对奇数进行检验即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 std::vector\u0026lt;int\u0026gt; prime; std::vector\u0026lt;int\u0026gt; vis(N, 0); void Eratosthenes() { prime.push_back(2); for(int i = 3; i * i \u0026lt;= N; i += 2) { if(!vis[i]) { for(int j = i * i; j \u0026lt;= N; j += (2 * i)) { vis[j] = 1; } } } for(int i = 3; i \u0026lt;= N; i += 2) { if(!vis[i]) { prime.push_back(i); } } } 虽然这些优化可以让埃筛达到一个很好的优化，甚至在某些场景比欧拉筛还要快捷，但是埃筛的时间复杂度终究不是 $O(N)$。\n欧拉筛 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void euler(int n) { std::vector\u0026lt;bool\u0026gt; vis(n + 1, 0); std::vector\u0026lt;int\u0026gt; primes; for(int i = 2; i \u0026lt;= n; ++i) { if(!vis[i]) { primes.push_back(i); } for(auto \u0026amp;prime : primes) { if(1LL * prime * i \u0026gt; n) break; vis[prime * i] = true; if(i % prime == 0) break; } } } [!hint]- 说明 核心 ： 欧拉筛确保每一个合数只被他自己的最小质因数筛去。\n$for\\ i\\ \\dots n$ ， 维护一个 prime 数组，表示到 $i$ 为止的所有质数。\n设 $p_{i}$ 为 $i$ 的最小质因子，在 $prime$ 数组中 : prime: $[\\underbrace{\\dots\\dots}_{\\text{p}_{j}}\\ , \\quad \\underset{\\substack{\\uparrow \\\\ \\text{pi}}}{\\boxed{p_i}}, \\quad \\dots ]$\n$p_{j}$ 表示所有小于 $p_{i}$ 的质数。 考虑 $newNum=i \\cdot p_{j}$ 。 已知 $p_{j}","date":"2025-05-25T14:07:56+08:00","permalink":"http://localhost:1313/p/%E6%B5%85%E8%B0%88%E7%AD%9B%E6%B3%95/","title":"浅谈筛法"},{"content":"简介 在算法竞赛中， 常常出现让答案对一个大质数进行取模的运算。由于模运算的性质，可以很容易的计算加法和减法。但是对于乘法，需要一些特殊的处理，这就是乘法逆元。\n定义 我们把 $a^{-1}$ 叫作 $a \\bmod p$ 的乘法逆元， 如果满足 $a\\cdot a^{-1} \\equiv 1 \\pmod p$。\n在高中数学中， 如果 $b\\cdot b^{-1}=1$， 就把 $b^{-1}$ 叫作 $b$ 的倒数， 即 $a / b = a\\cdot b^{-1}$。\n乘法逆元与之类似， 起到相似的作用。只不过作用域在 $\\bmod p$ 下。\n求解逆元 朴素枚举 由模运算的性质知道 $x \\equiv y \\pmod p\\ 肯定有\\ 0\\leq y\\leq p-1$ 。\n从 $1$ 到 $p-1$ 枚举判断是否有 $i$ 满足 $a\\cdot i \\equiv 1 \\pmod p$。\n时间复杂度为 $O(P)$ 。\n这个方法的唯一优点就是简单易想。\n费马小定理 表述 如果 $gcd(a,p)=1$ 则 $a^{p-1}\\equiv 1 \\pmod p$。\n关于费马小定理的证明有很多种，这里给出一种我认为最优雅的一种证明。\n考虑两个序列 :\n$i:[1,2,3,\\dots,p-1]$\n$j:[a,2a,3a, \\dots,(p-1)a]$\n现在证明 $i,j$ 在 $\\bmod p$ 意义下同构。\n也就是证明 $j$ 序列中两两不同在 $\\bmod p$ 意义下。\n假设 $j$ 序列中满足 $xa \\equiv ya \\pmod p \\ (1\\leq x,y\\leq p-1，x，y不同)$， 由模运算的性质得 $x \\equiv y \\pmod p$， 由于 $1\\leq x,y\\leq p-1$ ， $x \\text{只能等于} y$ ， 假设不成立，原命题得证。\n然后，我们把 $i，j$ 序列乘起来得到 $(p-1)!\\cdot a^{p-1} \\equiv (p-1)! \\pmod p$ ，$gcd((p-1)!,p)=1$，那么也就是 $a^{p-1}\\equiv 1 \\pmod p$。\n看向乘法逆元的定义 $：a\\cdot a^{-1} \\equiv 1 \\pmod p$， 对费马小定理进行变形得到 $a\\cdot a^{p-2} \\equiv 1 \\pmod p$，这就说明 $a^{p-2}$ 是 $a$ 的乘法逆元。注意者只有在 $p$ 是质数的时候成立。\n对于计算 $a^{p-2}$ ，可以用快速幂做到在 $O(log(p-2))$ 计算。\n快速幂 : 1 2 3 4 5 6 7 8 9 10 11 i64 binpow(i64 base, int exp, int mod) { i64 res = 1; base %= mod; while(exp) { if(exp \u0026amp; 1) res = res * base % mod; base = base * base % mod; exp \u0026gt;\u0026gt;= 1; } return res; } 拓展欧几里得算法 1 2 3 4 5 6 7 8 void Exgcd(int a, int b, int \u0026amp;x, int\u0026amp; y) { if(b == 0) { x = 1, y = 0; return ; } Exgcd(b, a % b, y, x); y -= a / b * x; } 线性递推 想象一下，如果你仅仅知道拓欧和费马小定理，你能不能想到可能存在一种 $O(N)$ 的方法求出逆元，我想不出。\n不过如果有人告诉你，存在一种方法，可以在线性时间内求出 $N$ 范围内的逆元，你会怎么去思考？\n如果是线性时间的话，那么我就要在 $O(1)$ 内求出一个数的逆元，要么我知道一个公式可以直接计算出逆元，要么我可以通过递推方程来得出，要么我可以通过某种方式均摊到 $O(1)$。\n很明显，直接套公式有点不太现实，费马没想到，欧拉没想到，他们都没想到，我不太认为我自己可能会想到。而且完全没有思路，不是吗？直觉告诉我，递推是最有可能的方案。\n不妨试一试，令 $i\\ 是\\ 1\\dots n$ 里面的任意一个数， $base$ 情况是 $1^{-1} \\equiv 1 \\pmod p$ 。\n$$ i^{-1} \\equiv \\begin{cases} 1, \u0026 \\text{if } i = 1, \\\\ 某种已知 情况, \u0026 \\text{otherwise}. \\end{cases} \\pmod p $$ 我们大胆猜测这个已知情况和一个小于 $i$ 的数有关，让我们想一想，哪里可以弄到小于 $i$ 的数又和 $i$ 有关呢？\n正巧，注意到 $p = k\\cdot i + r$， 这个 $r$ 不就小于 $i$ 吗？ (注意到这个不是没有理由的， 我们已知的信息就只有 $p,i$ ， 而把一个数写成 $ki+x$ 的形式在 $\\bmod$ 里是非常常见的，因为模运算就是这么定义的。)\n让我们来好好把玩把玩她 $: p=k\\cdot i+r$ ，$r=p\\%i$。\n先对等式两边取模得到 $$\\begin{gathered} 0 \\equiv k\\cdot i+r\\ (\\bmod p) \\\\ \\end{gathered} $$ 移项 $$\\begin{gather} -k\\cdot i \\equiv r \\ (\\bmod p) \\end{gather} $$ 乘 $i^{-1}$ $$ -k \\equiv r \\cdot i^{-1} \\pmod p $$ 把 $i^{-1}$ 拆出来 $$ i^{-1} \\equiv -k\\cdot r^{-1} \\pmod p $$ 代换 $r$ $$ i^{-1} \\equiv -k\\cdot (p\\%i)^{-1} \\pmod p $$ 重写 $k$ $$ i^{-1} \\equiv -\\left\\lfloor \\frac{p}{i} \\right\\rfloor\\cdot (p\\%i)^{-1} \\pmod p $$ 改成正数 $$ i^{-1} \\equiv (p-\\left\\lfloor \\frac{p}{i} \\right\\rfloor)\\cdot (p\\%i)^{-1} \\pmod p $$ 哈哈，这是什么，我们得到了一个式子，她完美的符合我们的猜想。\n$$ i^{-1} \\equiv \\begin{cases} 1, \u0026 \\text{if } i = 1, \\\\ i^{-1} \\equiv (p-\\left\\lfloor \\frac{p}{i} \\right\\rfloor)\\cdot (p\\%i)^{-1}, \u0026 \\text{otherwise}. \\end{cases} \\pmod p $$ 1 2 3 4 5 6 7 8 std::vector\u0026lt;i64\u0026gt; Inv(N, 1); const int mod = 998244353; void Inverse() { Inv[1] = 1; for(int i = 2; i \u0026lt; N; ++i) { Inv[i] = ((i64)(mod - mod / i) * Inv[mod % i]) % mod; } } 写出这个 $code$ ，易如反掌。\n不过这么写只能求出 $1\\dots n$ 的逆元，如果求给定任意 $a_{i}\\dots a_{i+n}$ 这 $n$ 个数的逆元，就要换种方法。\n利用类似前缀和的思想，首先计算 $n$ 个数的前缀积，记为 $s_i$，然后使用快速幂或扩展欧几里得法计算 $s_n$ 的逆元，记为 $sv_n$。\n因为 $sv_n$ 是 $n$ 个数的积的逆元，所以当我们把它乘上 $a_{i+n}$ 时，就会和 $a_{i+n}$ 的逆元抵消，于是就得到了 $a_i$ 到 $a_{i+n}$ 的积逆元，记为 $sv_{n-1}$。\n同理我们可以依次计算出所有的 $sv_i$，于是 $a_i^{-1}$ 就可以用 $s_{i-1} \\times sv_i$ 求得。\n所以我们就在 $O(n + \\log p)$ 的时间内计算出了 $n$ 个数的逆元。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 i64 modInv(i64 t) { return binpow(t, mod - 2, mod); } void Inverse(int n) { std::vector\u0026lt;i64\u0026gt; S(n + 1, 0), sInv(n + 1, 0); S[0] = 1; for(int i = 1; i \u0026lt;= n; ++i) { S[i] = S[i - 1] * arr[i - 1] % mod; } sInv[n] = modInv(S[n]); for(int i = n; i \u0026gt;= 1; --i) { sInv[i - 1] = sInv[i] * arr[i - 1] % mod; } for(int i = 0; i \u0026lt; n; ++i) { inv[i] = sInv[i + 1] * S[i] % mod; } } 本文部分内容参考自 OIwiki\n本文采用 CC BY-SA 4.0 国际许可协议进行许可。\n","date":"2025-05-25T13:59:19+08:00","permalink":"http://localhost:1313/p/multiplicative-inverse/","title":"Multiplicative Inverse"},{"content":"$Part\\ I.$ Static Variables in a Function 可以认为，声明在函数中被直接初始化的静态变量，就相当于把变量声明在全局，但是静态变量的作用域仅仅在函数内部其作用。\nStatic Member Variables in a Class 在类里面声明的静态变量分配空间时只被分配一次，所以类中所有实例化的对象中的静态变量相同，也就是静态变量和所有对象共享。也正是因为这个原因，静态变量不能使用构造函数进行初始化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; class GfG { public: // Static data member static int i; GfG(){ // Do nothing }; }; // Static member inintialization //int GfG::i = 1; int main() { // Prints value of i cout \u0026lt;\u0026lt; GfG::i; } 1 2 3 /tmp/ccPusLB5.o: In function `main\u0026#39;: Solution.cpp:(.text.startup+0xd): undefined reference to `GfG::i` collect2: error: ld returned 1 exit status 编译器在编译阶段为可能存在的 int GfG:: 打上引用，因为编译器假设 GfG::i 的定义会在其他地方提供，然而链接的阶段并没有找到为 GfG::i 分配空间的地方，所以抛出一个引用错误 undefined reference to GfG::i\nStatic Member Function in a Class 类似的，静态成员函数只能调用静态变量，被所有类共享。\nGlobal Static Variable 全局静态变量具有内部链接，也就是对于链接器来说，全局静态变量是看不见的，他只能被当前的翻译单元所访问，可以用来防止其他相同名字的其他文件变量冲突。注意定义在头文件中的静态变量作用域也被限制在当前的翻译单元，也就是对所有引用头文件的翻译单元来说，每个翻译单元都有一个静态变量的副本\nStatic 修饰的变量或者函数，导致的性质就是他的作用域会被改变，要想理解 static 关键词，应该先对程序的编译过程有一定的认识。\n参考链接\n$Part\\ II.$ $Tag\\ Dispatch$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // C++ Program to show the implementation of // tag dispatch #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; // Creating the different tags of type empty // struct struct t1{}; struct t2{}; // Defining a function for type t2 void fun(int a, t1) { cout \u0026lt;\u0026lt; \u0026#34;Calling function of tag t\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } // Defining the function with different // implementation for type t2 void fun(int a, t2) { cout \u0026lt;\u0026lt; \u0026#34;Function with tag t\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } int main() { // Function calling with different tags fun(1, t1{}); fun(2, t2{}); return 0; } 标签调度，其实是利用函数重载的一种 c++ 技巧，可以用来处理这样一种情况：你要做出不同的操作对具有相似参数和返回值的同名函数。\n这是一种静态多态($static\\ polymorphism$)\n参考博客\n$Part\\ III.$ $Duff's\\ Device$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; void copyIntArray(std::vector\u0026lt;int\u0026gt;\u0026amp; src, std::vector\u0026lt;int\u0026gt;\u0026amp; dest, int size) { int rounds = size / 8; int i = 0; switch(size % 8) { case 0: while(rounds-- \u0026gt; 0) { dest[i] = src[i++]; case 7 : dest[i] = src[i++]; case 6 : dest[i] = src[i++]; case 5 : dest[i] = src[i++]; case 4 : dest[i] = src[i++]; case 3 : dest[i] = src[i++]; case 2 : dest[i] = src[i++]; case 1 : dest[i] = src[i++]; }; } } int main () { int size = 20; std::vector\u0026lt;int\u0026gt; src(size, 0), dest(20); std::iota(src.begin(), src.end(), 1); copyIntArray(src, dest, size); for(int i = 0; i \u0026lt; size; ++i) { std::cout \u0026lt;\u0026lt; dest[i] \u0026lt;\u0026lt; std::endl; } return 0; } 利用 switch 语句的特性进行非常奇怪的操作，这被叫做 $Duff's\\ device$， 可以用来模拟 C++ 的协程，但是在 C++20 版本已经提供了官方封装的协程。\nHow does Duff\u0026rsquo;s Device work?\n$Part\\ IV.$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 #pragma once #include \u0026lt;optional\u0026gt; #include \u0026lt;stdexcept\u0026gt; /* * A Ref\u0026lt;T\u0026gt; represents a \u0026#34;borrowed\u0026#34;-or-\u0026#34;owned\u0026#34; reference to an object of type T. * Whether \u0026#34;borrowed\u0026#34; or \u0026#34;owned\u0026#34;, the Ref exposes a constant reference to the inner T. * If \u0026#34;owned\u0026#34;, the inner T can also be accessed by non-const reference (and mutated). */ template\u0026lt;typename T\u0026gt; class Ref { static_assert( std::is_nothrow_move_constructible_v\u0026lt;T\u0026gt; ); // Type Trait : 模板 T 是否是可移动构造的？ // _v : 获取类型特性模板类中 :: value , 在 c++17 之前 ，通过 std::is_nothrow_move_constructible\u0026lt;T\u0026gt;::value static_assert( std::is_nothrow_move_assignable_v\u0026lt;T\u0026gt; ); public: // default constructor -\u0026gt; owned reference (default-constructed) Ref() requires std::default_initializable\u0026lt;T\u0026gt; : obj_( std::in_place ) {} // construct from rvalue reference -\u0026gt; owned reference (moved from original) Ref( T\u0026amp;\u0026amp; obj ) : obj_( std::move( obj ) ) {} // NOLINT(*-explicit-*) // move constructor: move from original (owned or borrowed) Ref( Ref\u0026amp;\u0026amp; other ) noexcept = default; // move-assignment: move from original (owned or borrowed) Ref\u0026amp; operator=( Ref\u0026amp;\u0026amp; other ) noexcept = default; // borrow from const reference: borrowed reference (points to original) static Ref borrow( const T\u0026amp; obj ) { Ref ret { uninitialized }; ret.borrowed_obj_ = \u0026amp;obj; return ret; } // duplicate Ref by producing borrowed reference to same object Ref borrow() const { Ref ret { uninitialized }; ret.borrowed_obj_ = obj_.has_value() ? \u0026amp;obj_.value() : borrowed_obj_; return ret; } #ifndef DISALLOW_REF_IMPLICIT_COPY // implicit copy via copy constructor -\u0026gt; owned reference (copied from original) Ref( const Ref\u0026amp; other ) : obj_( other.get() ) {} // implicit copy via copy-assignment -\u0026gt; owned reference (copied from original) Ref\u0026amp; operator=( const Ref\u0026amp; other ) { if ( this != \u0026amp;other ) { obj_ = other.get(); borrowed_obj_ = nullptr; } return *this; } #else // forbid implicit copies Ref( const Ref\u0026amp; other ) = delete; Ref\u0026amp; operator=( const Ref\u0026amp; other ) = delete; #endif ~Ref() = default; bool is_owned() const { return obj_.has_value(); } bool is_borrowed() const { return not is_owned(); } // accessors // const reference to object (owned or borrowed) const T\u0026amp; get() const { return obj_.has_value() ? *obj_ : *borrowed_obj_; } // mutable reference to object (owned only) T\u0026amp; get_mut() { if ( not obj_.has_value() ) { throw std::runtime_error( \u0026#34;attempt to mutate borrowed Ref\u0026#34; ); } return *obj_; } operator const T\u0026amp;() const { return get(); } // NOLINT(*-explicit-*) operator T\u0026amp;() { return get_mut(); } // NOLINT(*-explicit-*) const T* operator-\u0026gt;() const { return \u0026amp;get(); } T* operator-\u0026gt;() { return \u0026amp;get_mut(); } explicit operator std::string_view() const requires std::is_convertible_v\u0026lt;T, std::string_view\u0026gt; { return get(); } T release() { if ( obj_.has_value() ) { return std::move( *obj_ ); } #ifndef DISALLOW_REF_IMPLICIT_COPY return get(); #else throw std::runtime_error( \u0026#34;Ref::release() called on borrowed reference\u0026#34; ); #endif } private: const T* borrowed_obj_ {}; std::optional\u0026lt;T\u0026gt; obj_ {}; struct uninitialized_t {}; static constexpr uninitialized_t uninitialized {}; explicit Ref( uninitialized_t /*unused*/ ) {} }; template\u0026lt;typename T\u0026gt; static Ref\u0026lt;T\u0026gt; borrow( const T\u0026amp; obj ) { return Ref\u0026lt;T\u0026gt;::borrow( obj ); } $Q \\\u0026 A$\nstatic_assert 是做什么用的？为什么这里要检查 std::is_nothrow_move_constructible_v\u0026lt;T\u0026gt; 和 std::is_nothrow_move_assignable_v\u0026lt;T\u0026gt;？如果 T 类型不满足这些条件会怎么样？\n默认构造函数 Ref() 后面的 requires std::default_initializable\u0026lt;T\u0026gt; 是什么意思？它和普通的构造函数有什么区别？\nstd::optional\u0026lt;T\u0026gt; obj_ 和 const T* borrowed_obj_ 这两个成员变量是如何协同工作来表示 \u0026ldquo;owned\u0026rdquo; 和 \u0026ldquo;borrowed\u0026rdquo; 状态的？为什么不直接用一个指针和一个布尔标志位？\nstruct uninitialized_t {}; static constexpr uninitialized_t uninitialized {}; 和私有构造函数 explicit Ref(uninitialized_t) 这一套组合的目的是什么？为什么 borrow 函数需要这样创建一个 Ref 对象？\n#ifndef DISALLOW_REF_IMPLICIT_COPY ... #else ... #endif 这段预处理指令是用来做什么的？为什么会有允许或禁止隐式拷贝的选项？拷贝构造函数和拷贝赋值运算符在 \u0026ldquo;owned\u0026rdquo; 和 \u0026ldquo;borrowed\u0026rdquo; 状态下是如何工作的？\noperator const T\u0026amp;() const 和 operator T\u0026amp;() 这两个类型转换运算符为什么没有 explicit 关键字 (注释中提到了 NOLINT(*-explicit-*))？它们允许什么样的隐式转换，这在实际使用中会有什么好处或潜在风险？\nT release() 函数在 Ref 是 \u0026ldquo;owned\u0026rdquo; 和 \u0026ldquo;borrowed\u0026rdquo; 状态时行为有什么不同？为什么在 \u0026ldquo;borrowed\u0026rdquo; 状态下（如果 DISALLOW_REF_IMPLICIT_COPY 被定义）会抛出异常？std::move(*obj_) 的作用是什么？\n文件末尾的自由函数 template\u0026lt;typename T\u0026gt; static Ref\u0026lt;T\u0026gt; borrow(const T\u0026amp; obj) 和类内部的静态成员函数 static Ref borrow(const T\u0026amp; obj) 有什么区别？为什么会提供一个自由函数版本？这里的 static 用在自由函数模板上是什么意思？\n除了类型转换运算符，代码还重载了 operator-\u0026gt;() 和 operator-\u0026gt;() const。这两个箭头运算符的重载允许我们像使用指针一样使用 Ref 对象（例如 ref_obj-\u0026gt;member_func()），它们是如何实现这一点的？在 \u0026ldquo;owned\u0026rdquo; 和 \u0026ldquo;borrowed\u0026rdquo; 状态下，它们分别返回什么？\n以上问题由 Gemini 生成。\n","date":"2025-05-24T22:40:03+08:00","permalink":"http://localhost:1313/p/c-%E6%9D%82%E9%A1%B9/","title":"C++ 杂项"},{"content":"有感而发，也算是一学年的总结吧。\n先引用一段《上海交通大学生存手册》的话吧。\n各位同学们，在本书的开始，我不得不遗憾地告诉大家一个消息。国内绝大部分大学的本科教学，不是濒临崩溃，而是早已崩溃。在此，我无意争论是否复旦、中科大、或者清华、北大是否比我们崩溃的更少一些——这种争论是没有意义的。我只是看到了无数充满求知欲、激情、与年轻梦想的同学们，将要把自己的四年青春，充满希望与信任地交给大学来塑造。这使我心中非常不安。\n其实我很庆幸，我的运气还算可以，我的信息检索能力也还说的过去。在高考刚刚结束，我就看到了《上海交通大学生存手册》，在学习 CS 不久，就了解到了 csdiy，虽然不是心仪的大学(高考发挥失常)，但起码是我自己选择的专业，是我有足够的热情，足够的兴趣去投入的专业。\n初入大学，我曾向一些优秀的学长请教选择 CS 专业的缘由，得到的答案却往往是“这个专业有潜力，能赚钱”这类现实考量。我不禁好奇，在这宝贵的四年里，究竟有多少人真正怀揣着明确的目标与梦想，他们热切追求着什么，渴望达成何种成就，又将塑造怎样的未来？而此刻，当我敲下这些文字，耳边传来的却仍旧是室友沉浸于游戏的喧嚣。我并非自诩清醒或优越，只是深感如此挥霍青春，实在可惜，也着实令人惋叹。\n从小就喜欢折腾的我，对 CS 感兴趣也许并不是一件值得惊讶的事，然而由于设备限制，我对于 CS 的了解，其实非常非常的肤浅。我不懂命令行，不懂编程语言，不懂网络。基本上，我是一个什么都不会的小白。也许，会用几个插件，知道几个软件，折腾过 windows 系统，这些简单的事情，甚至足以让我以为我对电脑非常的了解。放在现在来看，简直是羞愧难当。但不管怎么说，为了搞懂这些，我学会了搜索，习惯了查看文档，这总归算是个不错的开端。\n高考终究是阶段性的选拔手段，任何选拔手段都不能做到面面俱到从而帮助高校录取到他们最想要的学生，由于中小学的教育几乎都是为了高考选拔服务（读国外本科的同学除外），很多同学潜移默化中形成了线性的思维模式。在大学里也会有学积分的评价标准，但大学中已经不再像高考录取那样只靠成绩这一单一维度来线性地评价一个人的优秀程度，本科毕业时大家的发展与入学时的高考分数关系不大，其间四年里会有无数机遇等待着你把握，他们也会极大影响着你未来人生的走向，待毕业走到社会上之后你会发现虽然统计意义上来讲毕业院校越好他所达成的成就越高，但每个学校毕业生的出路方差却会大到你无法想象。\n然而，更令人沮丧的是，我身边愿意下功夫去‘卷’的同学已是少数，而在这少数人中，能够不被学分绩点裹挟、真正为知识本身而努力的，更是屈指可数。诚如作者所言，大学的本科教育早已崩溃，就我自身体验过的学校开设过的课程，可以说只有 C 语言能够称得上是有些用处的。即便如此，它也远不足以成为在业界安身立命的基石。至于剩下的课程，你甚至都不知道这些课开出来的意义在于何处。\n“你想要做什么？”——高考之后，这个问题时常萦绕在我心头。刚入学时，我是非常迷茫的。家里的期望和进入新环境的迷茫，让我方向尽失。寒假，总归是想了明白，你是没办法“grasp all and win all”的，汲汲于学分绩点非我本意，而耽于安逸、虚度光阴亦非我所求。以至于我有些后悔，为什么当初没有开始自学的道路，为什么还是要按部就班的去学习学校的课程。而有些事情，在现在还在拖累我的步伐。\n无论做什么，我们都需要给自己一个理由。每天迫于生活压力，毫无主见地忙碌着，可称得上人生一大悲哀。\n在迈进大学校门的时候，我们面临的最大问题是：为什么要上课？也许是因为问题本身太过浅显，以至于我们甚至懒于思考。但我们之中又有谁真正有效地思考过这个问题呢？\n“怕老师点名”“为了抄笔记作业”“记录考试重点”……这些话，充其量只是我们被迫上课的借口，却不能成为我们心悦诚服去上课的理由。\n真正能成为我们上课理由的，只有我们对科学文化知识的渴望。\n如果是否上课对你的考试成绩影响不大；如果我们感兴趣的知识不在学校的课程表上；如果上课学习的效果足够差，效率足够低，以至于通过自习，能够在更短的时间掌握知识；那么你还需要去上课吗？\n尽管现状如此，我仍然在网上见到了许多仰慕的对象，也有足够多的人和我观点契合，更有前辈已经为我们搭建好了平台供我们学习。人们也逐步认识到了学校教育的不足，自发的走上自学的道路。\n请记住，总有更加值得做的事，请把目光放的长远，不要为了 GPA 而上课，去独立思考，上课，学习，考试这些事情是否真的值得去做，日复一日的习题锻炼是否真的有必要执行。我们之所以拒绝学习那些对自己不是特别有用的知识，是因为这些知识对我们的价值太低。\n切勿指望学校亲自为你安排一条康庄大道，真正的路终究是需要自己一步一个脚印踏出来的。\n学习不一定是痛苦的，但是没有痛苦的学习，感受不到开心的学习，是没有收获的。\n最后，引用 csdiy 的一段话作为结语\n你得有足够的驱动力强迫自己静下心来，阅读几十页的 Project Handout，理解上千行的代码框架，忍受数个小时的 debug 时光。而这一切，没有学分，没有绩点，没有老师，没有同学，只有一个信念 —— 你在变强。\n","date":"2025-05-24T22:31:23+08:00","permalink":"http://localhost:1313/p/no-title/","title":"No Title"},{"content":" [!quote] A fine quotation is a diamond on the finger of a man of wit, and a pebble in the hand of a fool. — Joseph Roux\n我们要证明的等式是： $$ \\gcd(\\operatorname{lcm}(a,b), \\operatorname{lcm}(a,c)) = \\operatorname{lcm}(a, \\gcd(b,c)) $$ 基础：唯一分解定理（算术基本定理） 证明的关键在于使用唯一分解定理。该定理指出，任何大于 1 的整数都可以唯一地分解为素数的乘积（不考虑顺序）。\n形式一： 对于 $\\forall n \\in \\mathbb{Z}, n \u003e 1$，存在唯一的不同素数集合 $\\{p_1, \\dots, p_k\\}$ 和唯一的正整数指数集合 $\\{\\alpha_1, \\dots, \\alpha_k\\}$ 使得： $$ n = p_1^{\\alpha_1} p_2^{\\alpha_2} \\cdots p_k^{\\alpha_k} = \\prod_{i=1}^{k} p_i^{\\alpha_i} $$ 形式二（更适用于证明）： 对于 $\\forall n \\in \\mathbb{Z}, n \u003e 1$，其分解可以写成包含所有素数的形式： $$ n = \\prod_{p \\text{ prime}} p^{\\nu_p(n)} $$ 其中 $\\nu_p(n)$ 是素数 $p$ 在 $n$ 分解中的（非负）指数。对于给定的 $n$，只有有限个 $\\nu_p(n)$ 大于 0。\n使用素数指数表示 GCD 和 LCM 根据唯一分解定理，我们可以通过比较整数分解中每个素数 $p$ 的指数来计算最大公约数 (gcd) 和最小公倍数 (lcm)：\n对于任意素数 $p$： $p$ 在 $\\gcd(x, y)$ 中的指数是 $\\nu_p(\\gcd(x, y)) = \\min(\\nu_p(x), \\nu_p(y))$ $p$ 在 $\\operatorname{lcm}(x, y)$ 中的指数是 $\\nu_p(\\operatorname{lcm}(x, y)) = \\max(\\nu_p(x), \\nu_p(y))$ 例子： 设 $a = 12 = 2^2 \\cdot 3^1 \\cdot 5^0$ 设 $b = 30 = 2^1 \\cdot 3^1 \\cdot 5^1$\n计算 $\\gcd(12, 30)$:\n素数 2: 指数 $\\min(2, 1) = 1$ 素数 3: 指数 $\\min(1, 1) = 1$ 素数 5: 指数 $\\min(0, 1) = 0$ 所以 $\\gcd(12, 30) = 2^1 \\cdot 3^1 \\cdot 5^0 = 6$ 计算 $\\operatorname{lcm}(12, 30)$:\n素数 2: 指数 $\\max(2, 1) = 2$ 素数 3: 指数 $\\max(1, 1) = 1$ 素数 5: 指数 $\\max(0, 1) = 1$ 所以 $\\operatorname{lcm}(12, 30) = 2^2 \\cdot 3^1 \\cdot 5^1 = 60$ 证明过程 我们的策略是证明对于任意素数 $p$，它在等式左边 (LHS) 和右边 (RHS) 的指数都相等。根据唯一分解定理，如果所有素数的指数都对应相等，则这两个数必然相等。\n设对于任意素数 $p$，其在 $a, b, c$ 中的指数分别为 $\\alpha = \\nu_p(a)$, $\\beta = \\nu_p(b)$, $\\gamma = \\nu_p(c)$。\n1. 计算 LHS 中 $p$ 的指数： LHS = $\\gcd(\\operatorname{lcm}(a,b), \\operatorname{lcm}(a,c))$\n$p$ 在 $\\operatorname{lcm}(a,b)$ 中的指数为 $\\max(\\alpha, \\beta)$。 $p$ 在 $\\operatorname{lcm}(a,c)$ 中的指数为 $\\max(\\alpha, \\gamma)$。 根据 gcd 的指数规则， $p$ 在 LHS 中的指数为： $$ \\nu_p(\\text{LHS}) = \\min(\\max(\\alpha, \\beta), \\max(\\alpha, \\gamma)) $$ 2. 计算 RHS 中 $p$ 的指数： RHS = $\\operatorname{lcm}(a, \\gcd(b,c))$\n$p$ 在 $\\gcd(b,c)$ 中的指数为 $\\min(\\beta, \\gamma)$。 根据 lcm 的指数规则，$p$ 在 RHS 中的指数为： $$ \\nu_p(\\text{RHS}) = \\max(\\alpha, \\min(\\beta, \\gamma)) $$ 3. 证明指数相等： 我们需要证明 $\\nu_p(\\text{LHS}) = \\nu_p(\\text{RHS})$，即： $$ \\min(\\max(\\alpha, \\beta), \\max(\\alpha, \\gamma)) = \\max(\\alpha, \\min(\\beta, \\gamma)) $$ 这个等式是 $\\min$ 和 $\\max$ 运算的一个基本性质，称为分配律。这里用到的是 max 对 min 的分配律: $$ \\max(x, \\min(y, z)) = \\min(\\max(x, y), \\max(x, z)) $$ 令 $x = \\alpha$, $y = \\beta$, $z = \\gamma$，我们直接应用此分配律： $$ \\max(\\alpha, \\min(\\beta, \\gamma)) = \\min(\\max(\\alpha, \\beta), \\max(\\alpha, \\gamma)) $$ 这表明 $\\nu_p(\\text{RHS}) = \\nu_p(\\text{LHS})$。\n结论： 由于对于任意素数 $p$，它在等式两边的指数都相等，根据唯一分解定理，这两个表达式代表的整数必然相等。\n因此，原等式 $\\gcd(\\operatorname{lcm}(a,b), \\operatorname{lcm}(a,c)) = \\operatorname{lcm}(a, \\gcd(b,c))$ 成立。\n$Q.E.D.$\n算术基本定理及其证明 算术基本定理 (Fundamental Theorem of Arithmetic): 任何大于 1 的整数 $n$ 都可以被唯一地分解成有限个素数的乘积（不考虑因子的顺序）。 即：对于任意整数 $n \u003e 1$，存在唯一的不同素数集合 $\\{p_1, \\dots, p_k\\}$ 和唯一的正整数组 $\\{\\alpha_1, \\dots, \\alpha_k\\}$ 使得： $$ n = p_1^{\\alpha_1} p_2^{\\alpha_2} \\cdots p_k^{\\alpha_k} = \\prod_{i=1}^{k} p_i^{\\alpha_i} $$ 证明 证明分为两部分：存在性和唯一性。\n第一部分：存在性证明（强归纳法） 我们要证明任何整数 $n \u003e 1$ 都可以写成素数的乘积。\n基础情况: 当 $n=2$ 时，2 本身是素数，已是素数乘积。成立。 归纳假设: 假设对于所有满足 $1 \u003c k \u003c n$ 的整数 $k$，$k$ 都可以表示成素数的乘积。 归纳步骤: 考虑整数 $n$： 情况 A: 如果 $n$ 是素数，则它已是素数乘积。 情况 B: 如果 $n$ 是合数，则 $n = a \\cdot b$，其中 $1 \u003c a \u003c n$ 且 $1 \u003c b \u003c n$。根据归纳假设，$a$ 和 $b$ 都可以写成素数乘积： $$ a = p_1 p_2 \\cdots p_r $$ $$ b = q_1 q_2 \\cdots q_s $$ 其中所有 $p_i, q_j$ 都是素数。那么： $$ n = a \\cdot b = (p_1 \\cdots p_r)(q_1 \\cdots q_s) $$ 这表明 $n$ 也可以写成素数的乘积。 根据强归纳法，存在性得证。\n第二部分：唯一性证明（使用欧几里得引理和反证法） 我们需要用到一个关键引理：\n欧几里得引理 (Euclid\u0026rsquo;s Lemma): 如果素数 $p$ 整除乘积 $ab$ (记作 $p | ab$)，那么 $p$ 必须整除 $a$ 或 $p$ 必须整除 $b$ (即 $p | a$ 或 $p | b$)。 推论: 如果素数 $p$ 整除 $a_1 a_2 \\cdots a_k$，则 $p$ 至少整除其中一个 $a_i$。\n证明唯一性（反证法）：\n假设: 假设存在大于 1 的整数拥有至少两种不同的素数分解。根据良序原则（最小数原理），必然存在一个最小的这样的整数，记为 $n$。 分析 $n$: 设 $n$ 有两种不同的分解： $$ n = p_1 p_2 \\cdots p_r = q_1 q_2 \\cdots q_s $$ 其中 $p_i$ 和 $q_j$ 都是素数，并且作为多重集（考虑重复次数） $\\{p_1, \\dots, p_r\\} \\neq \\{q_1, \\dots, q_s\\}$。由于 $n$ 是最小的反例，任何小于 $n$ 的整数 $m \u003e 1$ 的素数分解是唯一的。 应用引理: 考虑 $p_1$。显然 $p_1 | n$，所以 $p_1 | (q_1 q_2 \\cdots q_s)$。根据欧几里得引理的推论，$p_1$ 必须整除某个 $q_j$。因为 $p_1$ 和 $q_j$ 都是素数，这只可能在 $p_1 = q_j$ 时发生。 约去公共因子: 不失一般性，重排 $q$ 使得 $p_1 = q_1$。等式两边同除以 $p_1$： $$ \\frac{n}{p_1} = p_2 p_3 \\cdots p_r = q_2 q_3 \\cdots q_s $$ 导出矛盾: 令 $m = n/p_1$。因为 $n$ 是合数（否则分解唯一），所以 $1 \u003c m \u003c n$。我们得到了整数 $m$ 的两种分解 $p_2 \\cdots p_r$ 和 $q_2 \\cdots q_s$。由于 $\\{p_1, \\dots, p_r\\}$ 和 $\\{q_1, \\dots, q_s\\}$ 不同，去掉相同的 $p_1=q_1$ 后，$\\{p_2, \\dots, p_r\\}$ 和 $\\{q_2, \\dots, q_s\\}$ 也必定不同。 这表明 $m$ 是一个比 $n$ 更小的、拥有不同素数分解的整数。这与 $n$ 是具有此性质的最小整数的假设相矛盾！ 结论: 初始假设错误。因此，任何整数 $n \u003e 1$ 的素数分解是唯一的（在不考虑顺序时）。 $Q.E.D.$\n","date":"2025-04-21T22:35:59+08:00","permalink":"http://localhost:1313/p/gcd-and-lcm/","title":"GCD and LCM"},{"content":"老爷子的线性代数课层层递进，深入浅出，引人入胜，只能说不愧是享誉盛名的教授，盛名之下无虚士。\n老爷子用的教材是他自己写的书：\n《Introduction To Linear Algebra Fifth Edition》\n教材和答案在 MIT Open Source 的官网上都有。\n老爷子的一个网站：\nwebsite 2023年5月15日，Gilbert Strang 上完了他在 18.06 的最后一课，以88岁高龄结束了在其 MIT 61年的教学及科研生涯。 但他的线性代数课已经并且还将继续影响一代代青年学子，让我们向老先生致以最崇高的敬意。\n― zhongyinmin@pku.edu.cn 老爷子在油管上的评论：\nPosted on behalf of Gil Strang:\nThis is my chance to thank everyone for such generous messages about my last lecture at MIT. I am almost tempted to have second thoughts about retirement \u0026hellip;\u0026hellip;\nbut it is the right time. Teaching has been a wonderful life.\nAnd I am so grateful to everyone who likes linear algebra and sees its importance.\nSo many universities ( and even high schools ) now appreciate how beautiful it is and how valuable it is. That movement will continue because it is right.\nI thank you for your good thoughts. I appreciate them more than I can say.\nVery best wishes in all your work\nGil\nLast Class 配合3b1b的视频一起食用味道更佳：\nYutube Bilibili 1 2 Any student who has taken this course will always remember the professor. We extend our highest respect to the professor. 1 2 3 4 A teacher affects eternity; he can never tell where his influence stops. -Henry Adams 教师影响永恒；他永远无法知道他的影响在哪里停止。 -亨利·亚当斯 MIT Linear Algebra Open Source ","date":"2024-10-17T22:12:58+08:00","permalink":"http://localhost:1313/p/linear-algebra/","title":"Linear Algebra"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"http://localhost:1313/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nYouTube Privacy Enhanced Shortcode Twitter Simple Shortcode “In addition to being more logical, asymmetry has the advantage that its complete appearance is far more optically effective than symmetry.”\n— Jan Tschichold pic.twitter.com/gcv7SrhvJb\n\u0026mdash; Design Reviewed | Graphic Design History (@DesignReviewed) January 17, 2019 Vimeo Simple Shortcode bilibilibi Shortcode Gist Shortcode Gitlab Snippets Shortcode Quote Shortcode Stack adds a quote shortcode. For example:\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Anonymous book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Some book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Somebody","date":"2019-03-10T00:00:00Z","permalink":"http://localhost:1313/p/rich-content/","title":"Rich Content"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"http://localhost:1313/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"http://localhost:1313/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"http://localhost:1313/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/emoji-support/","title":"Emoji Support"}]